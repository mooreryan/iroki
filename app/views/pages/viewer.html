<!-- Copyright 2011 Jason Davies https://github.com/jasondavies/newick.js -->
<script src="parse_newick.js"></script>

<!-- Copyright 2016 Mike Bostock https://d3js.org -->
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="script.js"></script>


<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: 0;
}

#show-length {
  position: absolute;
  top: 10px;
  left: 10px;
}

.links {
  fill: none;
  stroke: #000;
}

.link-extensions {
  fill: none;
  stroke: #000;
  stroke-opacity: .25;
}

.labels {
  font: sans-serif;
}

.link--active {
  stroke: #000 !important;
  stroke-width: 1.5px;
}

.link-extension--active {
  stroke-opacity: .6;
}

.label--active {
  font-weight: bold;
}

div {
  border: 1px solid black;
}

</style>

<div id="color-select">
  <p> Change color! </p>

  <label for="black">Black</label>
  <input id="black" name="color" type="radio">

  <label for="white">White</label>
  <input id="white" name="color" type="radio" checked>

  <label for="blue">Blue</label>
  <input id="blue" name="color" type="radio">

  <label for="red">Red</label>
  <input id="red" name="color" type="radio">
</div>

<div id="add-circles">
  <p>Add circles!</p>

  <label for="green">Green</label>
  <input id="green" name="color" type="button">

  <label for="purple">Purple</label>
  <input id="purple" name="color" type="button">

</div>

<div>
  <p>Paste a newick tree!</p>
  <form id="newick-input-form">
    <label for="newick-input">Upload!</label>
    <input type="file" name="newick" id="newick-input">

    <label for="submit-newick">Then click submit!</label>
    <input type="submit" name="newick" id="submit-input">

  </form>
</div>

<div>
  <input type="file" id="uploader">
</div>

<div id="branch-length-select">
  <p> Branch length type </p>

  <label for="variable-length">Normal-o-gram</label>
  <input id="variable-length" name="branch-length" type="radio">

  <label for="constant-length">Clad-o-gram</label>
  <input id="constant-length" name="branch-length" type="radio">
</div>

<div id="branch-type-select">
  <p> Branch type type </p>

  <label for="rectangle-type">Rectangle types</label>
  <input id="rectangle-type" name="branch-type" type="radio">

  <label for="straight-type">Straight types</label>
  <input id="straight-type" name="branch-type" type="radio">
</div>

<div id="font-size-select">
  <p>Change the font size!</p>
  <label for="font-size"></label>
  <input type="range" min="8" max="24" value="16" class="slider" id="font-size-slider">
</div>

<div id="show-labels-select">
  <p>Do you like labels!?</p>
  <label for="show-labels">Yes/No</label>
  <input type="checkbox" name="show-labels" id="show-labels" checked>
</div>

<div id="branch-width-select">
  <p>Branch width</p>

  <label for="branch-width"></label>
  <input type="range" min="1" max="10" value="2" class="slider" id="branch-width-slider">
</div>

<div id="angle-select">
  <p>Angles!!!</p>

  <form id="angle-select-form">
    <label for="side-to-side">Side to side</label>
    <input type="radio" name="angle" id="side-to-side">

    <label for="up-and-down">Up and down</label>
    <input type="radio" name="angle" id="up-and-down" checked>
  </form>
</div>


<script type="text/javascript">

// Copyright 2011 Jason Davies https://github.com/jasondavies/newick.js
function parseNewick(a){for(var e=[],r={},s=a.split(/\s*(;|\(|\)|,|:)\s*/),t=0;t<s.length;t++){var n=s[t];switch(n){case"(":var c={};r.branchset=[c],e.push(r),r=c;break;case",":var c={};e[e.length-1].branchset.push(c),r=c;break;case")":r=e.pop();break;case":":break;default:var h=s[t-1];")"==h||"("==h||","==h?r.name=n:":"==h&&(r.length=parseFloat(n))}}return r}

function lalala(tree_input) {
  var width = 1600

var height = 1600

var label_size = 16

var labels;
var links;
var circles;



var svg = d3.select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("id", "svg-tree")
    .style("background-color", "white");

var cluster = d3.cluster() // this adds the x and y attrs
    .size([width-50, height-50]) // adjust the 360 if you want to have a partial circle
    .separation(function(a, b) { return 1; });


// svg.append("g").attr("class", "apple").attr("id", "apple-chart");


function change_color(color) {
    var t = d3.transition().duration(250).ease(d3.easeSin);

    // Svg background
    d3.select("svg").transition(t).style("background-color", color);

    // Label background
    d3.select("#color-select p").transition(t).style("color", color);
}

function rand_num_under(val) {
    return Math.floor(Math.random() * val);
}

function add_circle(color) {
    var t = d3.transition().duration(1550).ease(d3.easeSin);

    var circle = svg.selectAll("circle")
        .data(circle_data(color));

    // What to do if there is extra data
    circle.exit().transition(t).attr("r", 0).remove();

    // What to do when adding new data
    circle.enter().append("circle")
        .attr("r", 0)
        .transition(t)
        .attr("r", 10)
        .attr("cx", function(d) { return d["x"]; })
        .attr("cy", function(d) { return d["y"]; })
        .style("fill", function(d) { return d.color; });

    // What to do when merging data
    circle
        .merge(circle)
        .transition(t)
        .attr("cx", function(d) { return d["x"]; })
        .attr("cy", function(d) { return d["y"]; })
        .style("fill", function(d) { return d.color; });
}

function circle_data(color) {
    return [
        {
            "x": rand_num_under(width),
            "y": rand_num_under(height),
            "color": color
        },
        {
            "x": rand_num_under(width),
            "y": rand_num_under(height),
            "color": color
        },
        {
            "x": rand_num_under(width),
            "y": rand_num_under(height),
            "color": color
        },
        {
            "x": rand_num_under(width),
            "y": rand_num_under(height),
            "color": color
        }
    ];
}


// Color change listeners
d3.select("#color-select #black")
    .on("change", function() { change_color("black") });
d3.select("#color-select #white")
    .on("change", function() { change_color("white") });
d3.select("#color-select #blue")
    .on("change", function() { change_color("blue") });
d3.select("#color-select #red")
    .on("change", function() { change_color("red") });

d3.select("#add-circles #green")
    .on("click", function() { add_circle("green") });
d3.select("#add-circles #purple")
    .on("click", function() { add_circle("purple") });





// font slider
var font_size_slider = document.getElementById("font-size-slider")
d3.select("#font-size-select label").html("Size: " + font_size_slider.value);
d3.select("input#font-size-slider").on("change", function() {
    // Set the label
    d3.select("#font-size-select label").html("Size: " + font_size_slider.value);

    // Update the font size
    labels.transition()
        .attr("font-size", font_size_slider.value + "px")
        .attr("dx", function(d) { return d[the_x] + label_offset_horizontal(); })
        .attr("dy", function(d) { return d[the_y] + label_offset_vertical(); });

});

// Set the label
var branch_width_slider = document.getElementById("branch-width-slider");
d3.select("#branch-width-select label").html("Width: " + branch_width_slider.value);
d3.select("input#branch-width-slider").on("change", function() {
    // Set the label
    d3.select("#branch-width-select label").html("Width: " + branch_width_slider.value);

    // Update the branch width
    links.transition()
        .attr("stroke-width", branch_width_slider.value + "px");
});

// // Set the radius of each node by recursively summing and scaling the distance from the root.
// function setRadius(d, y0, k) {
// }



function set_radius_up_and_down(d, y0, k) {
    d["radius"] = (y0 += d.data.length) * k;
    if (d.children) d.children.forEach(function(d) { setRadius(d, y0, k); });    
}

function set_radius_side_to_side(d, x0, k) {
    d["radius"] = (x0 += d.data.length) * k;
    if (d.children) d.children.forEach(function(d) { setRadius(d, x0, k); });    
}


// These two are for staight lines
function straight_link(d) {
    set_x_and_y();
    return "M " + d.source[the_x] + " " + d.source[the_y] + " L " + d.target[the_x] + " " + d.target[the_y];
}

function rectangle_link(d) {
    set_x_and_y();

    start_point = d.source[the_x] + " " + d.source[the_y]
    end_point   = d.target[the_x] + " " + d.target[the_y]

    if (document.getElementById("up-and-down").checked) {
        mid_point = d.target[the_x] + " " + d.source[the_y];
    } else {
        mid_point = d.source[the_x] + " " + d.target[the_y];
    }
    

    return "M " + start_point + " L " + mid_point + " L " + end_point;
}



// Up and down or side to side?
// Defaults for up and down
var the_x = "x";
var the_y = "radius"; // document.getElementById("variable-length").checked ? "radius" : "y";
var setRadius = set_radius_up_and_down;

function set_x_and_y() {
    is_variable_length_checked = document.getElementById("variable-length").checked;
    new_y_val = is_variable_length_checked ? "radius" : "y";


    if (document.getElementById("side-to-side").checked) {
        // Do side to side
        the_x =  new_y_val;
        the_y = "x";
        // setRadius = set_radius_side_to_side;
    } else {
        // Do up and down
        the_x = "x";
        the_y = new_y_val;
        // setRadius = set_radius_up_and_down;
    }

}

function update_angle() {
  tr = d3.transition().duration(750);
    set_x_and_y();

    circles.transition(tr).attr("cy", function (d) {
        return d.source[the_y];
    }).transition(tr).attr("cx", function(d) {
        return d.source[the_x];
    });

    labels
        .transition(tr).attr("dx", function(d) { return d[the_x] + label_offset_horizontal(); })
        .transition(tr).attr("dy", function(d) { return d[the_y] + label_offset_vertical(); })
        .attr("text-anchor", function(d) { return document.getElementById("side-to-side").checked ? "start" : "middle"; });

    links.transition(tr).attr("d", rectangle_type_button.checked ? rectangle_link : straight_link);


}

d3.select("form#angle-select-form").on("change", update_angle);

                // links.transition(tr).attr("d", constant_rectangle_link);
                // labels.transition(tr).attr("dy", function(d) { return d["y"] + label_offset_vertical(); });
                // circles.transition(tr).attr("cy", function(d) { return d.source["y"]; } );








// Check default radio buttons
var variable_length_button = document.getElementById("variable-length");
var constant_length_button = document.getElementById("constant-length");
variable_length_button.checked = true;

var rectangle_type_button = document.getElementById("rectangle-type");
var straight_type_button  = document.getElementById("straight-type");
rectangle_type_button.checked = true;

var show_labels_button = document.getElementById("show-labels");
d3.select("input#show-labels").on("change", function() {
    if (show_labels_button.checked) {
        labels.attr("opacity", "1");
    } else {
        labels.attr("opacity", "0");
    }
});


var pie = 10;

var chart = svg.append("g").attr("id", "apple-chart");
//     .attr("transform", "translate(" + outerRadius + "," + outerRadius + ")");

console.log(document.getElementById("newick-input").value);

    var root = d3.hierarchy(parseNewick(tree_input), function(d) { return d.branchset; })
    // // if it is a leave node, then it will have a node.value == 1
        .sum(function(d) { return d.branchset ? 0 : 1; })
        .sort(function(a, b) { return (a.value - b.value) || d3.ascending(a.data.length, b.data.length); });

    // console.log(parseNewick(life).branchset);

    // For some reason this works
    cluster(root);
    // but this d3.cluster(root) does not


    setRadius(root, root.data.length = 0, (height-50) / maxLength(root));


    root.each(function(d) { console.log("hi " + d.data.name);
                            console.log("x: " + d["x"] + " y: " + d["y"] + " radius: " + d["radius"]) } );

    // var linkExtension = chart.append("g")
    //     .attr("class", "links")
    //     .selectAll("path")
    //     .data(root.links().filter(function(d) { return !d.target.children; }))
    //     .enter().append("path")
    //     .style("stroke", "orange")
    //     .each(function(d) { d.target.linkExtensionNode = this; })
    //         .attr("d", function(d) { return
    //                                  "M " + d.source["x"] + " " + d.source["y"] +
    //                                  " L " + d.target["x"] + " " + d.target["y"] });

    links = chart.append("g")
        .attr("class", "links")
        .selectAll("path")
        .data(root.links())
        .enter().append("path")
        .attr("stroke-width", function() { return branch_width_slider.value + "px"; } )
        .style("stroke", "brown")
        .each(function(d) { d.target.linkExtensionNode = this; })
            .attr("d", rectangle_link);


    circles = chart.append("g")
        .attr("class", "circles")
        .selectAll("circle")
        .data(root.links()) // just links to leaves
        .enter().append("circle")
        .attr("r", 5)
        .attr("cx", function(d) { return d.source["x"]; } )
        .attr("cy", function(d) { return d.source["radius"]; } )
        .style("fill", "black");

    // chart.append("g")
    //     .selectAll("text")
    //     .data(root.links().filter(function(d) { return !d.target.children; }))
    //     .enter().append("text")
    //     .attr("dx", function(d) { return d.source["x"]; } )
    //     .attr("dy", function(d) { return d.source["y"]; } )
    //     .text(function(d) { return d.source.data.name + " -> " + d.target.data.name; });

    labels = chart.append("g")
        .attr("class", "labels")
        .selectAll("text")
        .data(root.leaves())
        .enter().append("text")
        .attr("class", "leaf-labels")
        .attr("dx", function(d) { return d["x"] + label_offset_horizontal(); } )
    // offset the y by label size to keep label from running into the branch
        .attr("dy", function(d) { return d["radius"] + label_offset_vertical(); } )
        .attr("text-anchor", "middle")
        .attr("font-size", label_size + "px")
        .text(function(d) { return d.data.name; })



    branch_length_listener(links, labels, circles);

function label_offset_vertical() {
    current_label_size = parseInt(font_size_slider.value)
    
    // // divide by three centers it on the branch
    return document.getElementById("side-to-side").checked ? Math.floor(current_label_size / 3) : current_label_size;
}

function label_offset_horizontal() {
    current_label_size = parseInt(font_size_slider.value)

    return document.getElementById("side-to-side").checked ? Math.floor(current_label_size / 2) : 0;

    return 0;
}


var current_link_function = rectangle_link;
function branch_length_listener(links, labels, circles) {
    // TODO this timer doesn't seem to work?
    var tr = d3.transition().duration(250)


    // normal gram vs cladogram
    d3.select("#branch-length-select")
        .on("change", function() {
            set_x_and_y();

            if (rectangle_type_button.checked) {
                current_link_function = rectangle_link;
                links.transition(tr).attr("d", rectangle_link);
            } else if (straight_type_button.checked) {
                current_link_function = straight_link;
                links.transition(tr).attr("d", straight_link);
            } else {
                //TODO
            }

            labels.transition(tr).attr("dx", function(d) { return d[the_x] + label_offset_horizontal(); })
                .attr("dy", function(d) { return d[the_y] + label_offset_vertical() ; });
            circles.transition(tr).attr("cx", function(d) { return d.source[the_x]; } )
                .attr("cy", function(d) { return d.source[the_y]; } );

        });

    d3.select("#branch-type-select").
        on("change", function() {
            set_x_and_y();

            if (rectangle_type_button.checked) {
                current_link_function = rectangle_link;
                links.transition(tr).attr("d", rectangle_link);
            } else if (straight_type_button.checked) {
                current_link_function = straight_link;
                links.transition(tr).attr("d", straight_link);
            } else {
                //TODO
            }

            labels.transition(tr).attr("dx", function(d) { return d[the_x] + label_offset_horizontal();  })
                .transition(tr).attr("dy", function(d) { return d[the_y] + label_offset_vertical(); });
            circles.transition(tr).attr("cx", function(d) { return d.source[the_x]; } )
                .transition(tr).attr("cy", function(d) { return d.source[the_y]; } );
        });
}



// the size of the circle
var outerRadius = 960 / 2,
    innerRadius = outerRadius - 170;


// Compute the maximum cumulative length of any node in the tree.
function maxLength(d) {
    return d.data.length + (d.children ? d3.max(d.children, maxLength) : 0);
}


// Set the color of each node by recursively inheriting.
function setColor(d) {
    var name = d.data.name;
    d.color = color.domain().indexOf(name) >= 0 ? color(name) : d.parent ? d.parent.color : null;
    if (d.children) d.children.forEach(setColor);
}

/*
function linkVariable(d) {
    return linkStep(d.source["x"], d.source["radius"], d.target["x"], d.target["radius"]);
}

function linkConstant(d) {
    return linkStep(d.source["x"], d.source["y"], d.target["x"], d.target["y"]);
}

function linkExtensionVariable(d) {
    return linkStep(d.target["x"], d.target["radius"], d.target["x"], innerRadius);
}

function linkExtensionConstant(d) {
    return linkStep(d.target["x"], d.target["y"], d.target["x"], innerRadius);
}

// Like d3.svg.diagonal.radial, but with square corners.
function linkStep(startAngle, startRadius, endAngle, endRadius) {
    var c0 = Math.cos(startAngle = (startAngle - 90) / 180 * Math.PI),
        s0 = Math.sin(startAngle),
        c1 = Math.cos(endAngle = (endAngle - 90) / 180 * Math.PI),
        s1 = Math.sin(endAngle);
    return "M" + startRadius * c0 + "," + startRadius * s0
        + (endAngle === startAngle ? "" : "A" + startRadius + "," + startRadius + " 0 0 " + (endAngle > startAngle ? 1 : 0) + " " + startRadius * c1 + "," + startRadius * s1)
        + "L" + endRadius * c1 + "," + endRadius * s1;
}
*/
}

// load dataset and create table
function load_dataset(file) {
  // Clear the current svg if it is there
  chart_elem = document.getElementById("svg-tree")
  if (chart_elem) {
    // d3.select("#apple-chart").transition().remove();
    chart_elem.parentNode.removeChild(chart_elem);
  }
  lalala(file);
}

// handle upload button
function upload_button(el, callback) {
  var uploader = document.getElementById(el);  
  var reader = new FileReader();

  reader.onload = function(e) {
    var contents = e.target.result;
    callback(contents);
  };

  uploader.addEventListener("change", handleFiles, false);  

  function handleFiles() {
    d3.select("#table").text("loading...");
    var file = this.files[0];
    reader.readAsText(file);
  };
};



</script>

<script>
upload_button("uploader", load_dataset);
</script>
